<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>JNI极速入门 | 海海杂说</title><link rel=icon type=image/x-icon href=/favicon/favicon-32x32.png><meta name=copyright content="© Copyright 2025. All rights reserved."><meta name=keywords content="JNI,Java Native Interface"><meta name=description content="JNI极速入门，JNI学习笔记，Java Native Interface，对JNI使用方法的学习"><meta name=robots content="index,follow"><link rel=stylesheet href=/css/main.min.cdf1df9f75a8c5bad628dcafe44fb0ec69ac8dbf5b0ff081ad5e6635b4eff990.css integrity="sha256-zfHfn3WoxbrWKNyv5E+w7Gmsjb9bD/CBrV5mNbTv+ZA=" crossorigin=anonymous><link rel=stylesheet href=/css/github-markdown.min.ee481479a5f04c7d701db0c6200f10242416b3f4d2a3c073fdc6a09e145dccb8.css integrity="sha256-7kgUeaXwTH1wHbDGIA8QJCQWs/TSo8Bz/cagnhRdzLg=" crossorigin=anonymous><link rel=stylesheet href=/css/iconfont.min.daa5136180ec22c6e9c0b91c926f85d1272434432a6bbd6cb3a571743fdfeb08.css integrity="sha256-2qUTYYDsIsbpwLkckm+F0SckNEMqa71ss6VxdD/f6wg=" crossorigin=anonymous><link rel=stylesheet href=/css/media.min.e90b6071ab53a9c302681b20f033844f4b7ff488d2a6225ea25533b9868f6244.css integrity="sha256-6QtgcatTqcMCaBsg8DOET0t/9IjSpiJeolUzuYaPYkQ=" crossorigin=anonymous><script src=/js/dayjs.min.js></script><script src=/js/relativeTime.js></script><script src=/js/zh-cn.js></script><script src=/js/main.f131ccf6104a927521a409081c405198f6e1a22c1adeff2e4f0c4e55ad2e2f65.js integrity="sha256-8THM9hBKknUhpAkIHEBRmPbhoiwa3v8uTwxOVa0uL2U=" crossorigin=anonymous></script><meta name=file content="posts/0005 按套路学习JNI/index.md"></head><body><header><div class=site-header><a href=https://www.lsz.sc.cn/ class=site-title><img src=/favicon/logo.png class=site-title-logo>
<span class=site-title-text>海海杂说</span></a><div></div><div class=site-menus><nav><ul><li><a href=/><i class="iconfont icon-home"></i>
首页</a></li><li><a aria-current=true class=ancestor href=/posts/><i class="iconfont icon-medium"></i>
博客</a></li><li><a href=/products/><i class="iconfont icon-chanpin"></i>
产品</a></li><li><a href=/moments/><i class="iconfont icon-shejiaotubiao-02"></i>
动态</a></li><li><a href=/about/><i class="iconfont icon-guanyuwomen"></i>
关于</a></li></ul></nav></div></div></header><main><div class=details><div class=details-title>JNI极速入门</div><hr class=divider><div class=created>发表于：2025-09-18 19:56:38</div><div class="content markdown-body"><p><code>JNI</code>(Java Native Interface，Java本地接口)，是Java平台的标准组成部分，是Java与本地代码连接的桥梁。在Android开发中，普遍通过NDK来使用JNI。</p><blockquote><p>用大白话说就是，要在Java中调用C/C++的函数，就需要用JNI。</p></blockquote><p><code>NDK</code>(Native Development Kit)，是用于在Java代码中集成原生代码的工具集。</p><p>学习JNI，主要就是要明白JNI的规则：</p><ul><li>在Java中的命名是什么样的？</li><li>在C/C++中的命名是什么的？</li><li>他们是如何关联起来的？</li></ul><p>当然，我们的学习还是要从基本的环境搭建说起。</p><blockquote><p>Android Studio的安装，我们就不介绍了。</p></blockquote><h1 id=ndk安装>NDK安装</h1><p>Android Studio为我们集成了NDK的安装选项，我们只需要勾选上即可。</p><p>打开<code>File ---> Settings ---> Languages & Frameworks ---> Android SDK</code>，选择选项卡<code>SDK Tools</code>，再在列表中找到<code>NDK(Side by side)</code>，勾选你需要的NDK版本，最后点击<code>OK</code>。</p><p><img src=/posts/jni/image.png alt=NDK></p><hr><p>在上面，我们安装好了NDK，接下来我们就开始通过一个简单的例子来完成在Java中调用C/C++的代码。</p><h1 id=目标描述>目标描述</h1><p>我们需要实现一个<code>Math</code>类，完成以下功能：</p><ul><li>乘法(mul) - 传入两个参数，返回两个参数的乘积。</li><li>除法(div) - 传入两个参数，一个被除数，一个除数，返回余数和商。</li></ul><h1 id=实现过程>实现过程</h1><h2 id=配置项目>配置项目</h2><p>在普通的项目中，是没有开启NDK的，所以我们如果要使用JNI，就需要先在<code>build.gradle</code>中配置好相关信息。</p><p>打开<code>app/build.gradle</code>文件，在<code>android ---> defaultConfig</code>中添加以下配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gradle data-lang=gradle><span style=display:flex><span>externalNativeBuild <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    cmake <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        arguments <span style=color:#e6db74>&#34;-DANDROID_ARM_NEON=TRUE&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;-DANDROID_PLATFORM=android-21&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;-DANDROID_STL=c++_shared&#34;</span>
</span></span><span style=display:flex><span>        abiFilters <span style=color:#e6db74>&#39;armeabi-v7a&#39;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#39;arm64-v8a&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>ndk <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    ldLibs <span style=color:#e6db74>&#34;log&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;z&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;m&#34;</span>
</span></span><span style=display:flex><span>    abiFilters <span style=color:#e6db74>&#34;armeabi-v7a&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;arm64-v8a&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在<code>externalNativeBuild</code>配置中，我们指定了使用<code>cmake</code>来进行构建，并设置了构建的参数，同时，指定了适配的CPU架构。</p><p>在<code>ndk</code>配置中，<code>ldLibs</code>指定了链接时需要包含的系统库。</p><p>在上面的配置中，同时存在<code>abiFilters</code>配置项，最终的so文件仅输出两个配置项中都存在(交集)的项。你也可以省略cmake中的abiFilters配置项。</p><p>然后，在<code>android</code>节点下添加以下配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gradle data-lang=gradle><span style=display:flex><span>externalNativeBuild <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    cmake <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        path <span style=color:#e6db74>&#34;src/main/cpp/CMakeLists.txt&#34;</span>
</span></span><span style=display:flex><span>        version <span style=color:#e6db74>&#34;3.10.2&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>sourceSets <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    main <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        jniLibs<span style=color:#f92672>.</span><span style=color:#a6e22e>srcDirs</span> <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#39;src/main/jniLibs&#39;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#39;libs&#39;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>ndkVersion <span style=color:#e6db74>&#39;21.0.6113669&#39;</span>
</span></span></code></pre></div><p><code>externalNativeBuild</code>中配置了<code>cmake</code>的相关参数。</p><ul><li>path - 指定了<code>CMakeLists.txt</code>的位置</li><li>version - 指定了cmake的版本。</li></ul><blockquote><p>这里的externalNativeBuild与defaultConfig中的externalNativeBuild作用是不一样的。</p><ul><li>defaultConfig中​的 externalNativeBuild ​​告诉 Gradle “怎么构建”​​（指定编译参数和选项）。</li><li>在 android块下​的 externalNativeBuild ​​告诉 Gradle “去哪找”和“用什么版本”来构建代码​​（指定脚本路径和版本）。</li></ul></blockquote><p>默认情况下，Android Studio 会到<code>src/main/jniLibs</code>目录下寻找按 ABI 子目录分好的 .so文件，我们这里又添加了一个libs目录。</p><p><code>ndkVersion</code>用来指定NDK的版本，这里选择我们刚才安装的版本。</p><h2 id=乘法实现>乘法实现</h2><p><strong>1. 添加Java类</strong></p><p>我们在这里要添加的是带<code>native</code>的Java类，供在其它地方调用，在调用<code>native</code>方法时，Java会自动调用对应的<code>C</code>函数。</p><p>我们这里是在<code>app/src/main/java/com/example/demo</code>中添加的<code>Math</code>类。</p><p>按照目标，我们需要给这个类添加两个方法，这两个方法<strong>一定</strong>要用<code>native</code>来修饰。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.example.demo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 我们这里先实现mul方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Math</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>loadLibrary</span>(<span style=color:#e6db74>&#34;math&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>native</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mul</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在调用<code>mul</code>前，需要先加载对应的库文件，将 System.loadLibrary()放在 static 静态代码块中是最可靠和推荐的方式。</p><p><strong>2. 添加CPP实现</strong></p><p>在<code>src/main/cpp</code>目录下添加<code>math.cpp</code>文件。</p><blockquote><p>如果<code>cpp</code>目录不存在，则手动创建。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;jni.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> jint Java_com_example_demo_Math_mul(JNIEnv<span style=color:#f92672>*</span> env, jclass self,jint a,jint b){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a<span style=color:#f92672>*</span>b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>extern &ldquo;C&rdquo;</strong> - 明确导出函数的名称与我们写的一致。</li><li><strong>jint</strong> - 返回的是一个jint类型，Java会自动翻译成对应的java类型。</li><li><strong>Java_com_example_demo_Math_mul</strong> 函数名称，与<code>Math</code>中<code>mul</code>方法路径一致。JNI中，名称以<code>Java_</code>开头，后面接Java类中对应的方法路径。</li></ul><p>函数参数：</p><ul><li><strong>JNIEnv</strong>* - JNI环境。</li><li>jclass - 静态方法中对应的类。</li><li><strong>jint a,jint b</strong> - mul对应的参数。</li></ul><blockquote><p>这里的写法都是按这个规则固定编写。</p></blockquote><p><strong>4. 添加CMakeLists.txt</strong></p><p>将库的名称指定为前面System.loadLibrary中对应的名称，这里固为<code>math</code>。</p><p>在刚才cpp文件的目录添加一个<strong>CMakeLists.txt</strong>文件，内容哪下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 指定最小版本
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cmake_minimum_required(<span style=color:#e6db74>VERSION</span> <span style=color:#e6db74>3.10.2</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 指定项目名称
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>project(<span style=color:#e6db74>&#34;math&#34;</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 定义要构建的库
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>add_library(<span style=color:#e6db74>math</span> <span style=color:#75715e># 目标库文件名称​​，Andorid上最终会生成 libmath.so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>SHARED</span> <span style=color:#75715e># 指定生成的是动态连接库
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e># 添加源文件，有多少个就添加多少个，这里只需要添加一个。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>math.cpp</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 其它依赖库
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>target_link_libraries(<span style=color:#e6db74>math</span> <span style=color:#75715e># 添加依赖库的目标（谁需要就写谁，这里是我们写的库需要，就写math
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e># 添加的依赖库
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#e6db74>android</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>log</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><blockquote><p>target_link_libraries 是在连接阶段将依赖库和我们的目标连接到一起。</p></blockquote><h2 id=除法实现>除法实现</h2><p>我们在上面的基础上实现除法，根据需求，除法需要返回商和余数，我们定义一个<code>DivResult</code>类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.example.demo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DivResult</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Quotient,Remainder;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>DivResult</span>(<span style=color:#66d9ef>int</span> q,<span style=color:#66d9ef>int</span> r){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>Quotient</span><span style=color:#f92672>=</span>q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>Remainder</span><span style=color:#f92672>=</span>r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>Math</code>添加方法<code>div</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>native</span> DivResult <span style=color:#a6e22e>div</span>(<span style=color:#66d9ef>int</span> dividend,<span style=color:#66d9ef>int</span> divisor);
</span></span></code></pre></div><p>在cpp中添加对应的除法实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> jobject Java_com_example_demo_Math_div(JNIEnv<span style=color:#f92672>*</span> env, jclass math,jint dividend,jint divisor){
</span></span><span style=display:flex><span>    jint q<span style=color:#f92672>=</span>dividend<span style=color:#f92672>/</span>divisor;
</span></span><span style=display:flex><span>    jint r<span style=color:#f92672>=</span>dividend<span style=color:#f92672>%</span>divisor;
</span></span><span style=display:flex><span>    jclass DR <span style=color:#f92672>=</span> env<span style=color:#f92672>-&gt;</span>FindClass(<span style=color:#e6db74>&#34;com/example/demo/DivResult&#34;</span>); <span style=color:#75715e>//获取类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    jmethodID constructor <span style=color:#f92672>=</span> env<span style=color:#f92672>-&gt;</span>GetMethodID(DR, <span style=color:#e6db74>&#34;&lt;init&gt;&#34;</span>, <span style=color:#e6db74>&#34;(II)V&#34;</span>); <span style=color:#75715e>//获取构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    jobject dr <span style=color:#f92672>=</span> env<span style=color:#f92672>-&gt;</span>NewObject(DR, constructor,q,r);<span style=color:#75715e>//调用构造函数，返回一个类的实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> dr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在除法中，我们需要返回的是一个Java类的实例，需要使用JNIEvn来实现Java类的操作。</p><blockquote><p>在FindClass中我们的类路径注意在release时，不要进行混淆，不然会找不到。</p></blockquote><h2 id=测试结果>测试结果</h2><p>固定使用<code>2*3</code>来测试乘法。</p><p><img src=/posts/jni/image-2.png alt=乘法></p><p>固定使用<code>10/3</code>来测试除法。</p><p><img src=/posts/jni/image-1.png alt=除法></p><h1 id=总结>总结</h1><p><code>JNI</code>的学习，更多的是规则的学习，学习如何将我们学过的其它知识如何连接在一起。</p><p>在前面，为了快速把JNI的流程和规则说清楚，对于一些详细的规则我们没有细说，比如JNI的类型与Java基本类型如何对应、JNIEvn中如何调用静态方法、静态库如何初始化一些信息等，你需要去参考官方文档。</p><p>同时，前面使用到了<code>gradle</code>、<code>cmake</code>等，你也需要去学习他们的语法。</p><blockquote><p>对于JNI所有的函数都可以在jni.h里找到原型。</p></blockquote></div></div></main><footer><p>© Copyright 2025. All rights reserved.</p><p><a href=https://beian.miit.gov.cn/#/Integrated/index target=_blank>蜀ICP备2023031169号-1</a></p></footer></body></html>